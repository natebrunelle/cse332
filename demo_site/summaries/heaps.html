<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>CSE332 - Topic Summary - Priority Queues and Heaps</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">q { quotes: "“" "”" "‘" "’"; }</style>
  <link rel="stylesheet" href="../style.css?v=2" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" />
  <style type="text/css">.katex { font-size: inherit; }</style>
</head>
<body>
    <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">CSE 332 &ndash; Topic Summary - Priority Queues and Heaps</span>
        <ul class="nav pull-right doc-info">
                    <li><p class="navbar-text"><a href="../index.html">Home</a></p></li>
          <li><p class="navbar-text"><a href="../syllabus.html">Syllabus</a></p></li>
          <li><p class="navbar-text"><a href="../calendar.html">Calendar</a></p></li>
          <li><p class="navbar-text"><a href="../tasks.html">Tasks</a></p></li>
          <li><p class="navbar-text"><a href="../summaries.html">Summaries</a></p></li>
          <li><p class="navbar-text"><a href="../oh.html">Office Hours</a></p></li>
          <li><p class="navbar-text"><a href="../staff.html">Staff</a></p></li>
        </ul>
      </div>
    </div>
  </div>
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">
        <ul>
          <li class="nav-header">Table of Contents</li>
        </ul>
        <ul>
        <li><a href="#priority-queue-adt"><span class="toc-section-number">1</span> Priority Queue ADT</a><ul>
        <li><a href="#priority-queues-using-lists"><span class="toc-section-number">1.1</span> Priority Queues Using Lists</a><ul>
        <li><a href="#unsorted-array-priority-queue"><span class="toc-section-number">1.1.1</span> Unsorted Array Priority Queue</a></li>
        <li><a href="#sortest-array-priority-queue"><span class="toc-section-number">1.1.2</span> Sortest Array Priority Queue</a></li>
        <li><a href="#lessons"><span class="toc-section-number">1.1.3</span> Lessons</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#binary-heap-data-structure"><span class="toc-section-number">2</span> Binary Heap Data Structure</a><ul>
        <li><a href="#the-shape-of-the-tree"><span class="toc-section-number">2.1</span> The Shape of the Tree</a></li>
        <li><a href="#somewhat-ordering-the-array"><span class="toc-section-number">2.2</span> Somewhat Ordering the Array</a></li>
        <li><a href="#the-tree-representation-using-an-array"><span class="toc-section-number">2.3</span> The Tree Representation Using an Array</a></li>
        <li><a href="#insert-and-extract-algorithms"><span class="toc-section-number">2.4</span> Insert and Extract Algorithms</a><ul>
        <li><a href="#insert"><span class="toc-section-number">2.4.1</span> Insert</a></li>
        <li><a href="#percolate-up-and-down"><span class="toc-section-number">2.4.2</span> Percolate Up and Down</a></li>
        <li><a href="#running-time-analysis"><span class="toc-section-number">2.4.3</span> Running time analysis</a></li>
        <li><a href="#increasedecrease-key"><span class="toc-section-number">2.4.4</span> Increase/Decrease Key</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#floyds-build-heap-method"><span class="toc-section-number">3</span> Floyd’s Build Heap Method</a></li>
        </ul>
        </div>
      </div>
            <div class="span9">
            <!--<blockquote style="background-color:#fbb; font-size:150%">This page is from a previous offering of the course. It has been left up for archival purposes.</blockquote>-->
      <!--<blockquote style="background-color:#fbb; font-size:150%">This page is under construction. Any content you see now is subject to change until the first day of class. Expect some links to be broken until that time.</blockquote>--> 
      <!--<blockquote style="background-color:#FFD700; font-size:150%">Looking for someone to talk to about CSE332? Try the Study Center in CSE room 006! There's a table there just for working on and discussing CSE332!</blockquote>-->
      <h1 id="priority-queue-adt"><span class="header-section-number">1</span> Priority Queue ADT</h1>
      <p>In this section we introduced a new ADT called a <em>priority queue</em>. As a reminder, the queue ADT allows for insertion and removal where the only item that may be removed is the least frequently added (yielding the <q>first in first out</q> behavior). In this way, a queue operates like a checkout line at a store where each shopper joins the line behind the person who arrived before them so that the one who had been there the longest is the next to be served.</p>
      <p>For a priority queue, instead of removing the least frequently added item, we will remove the most important item. We can think of this as a line where more important people are allowed to cut in front of less important people. For example, in an emergency room someone with an urgent need would see a doctor before someone with a less serious condition. In this case the urgency of the patient’s condition would determine the order that we service those waiting.</p>
      <p>With this motivation, here’s how we’ll define the priority queue ADT:</p>
      <ul>
      <li>Notion: A collection of items along with their priority levels</li>
      <li>Operations:
      <ul>
      <li>insert: adds a new element into the priority queue along with a given priority value</li>
      <li>extract: deletes and returns the most important element according to its priority value</li>
      <li>increaseKey: changes the priority value of the given element to make it larger</li>
      <li>decreaseKey: changes the priority value of the given element to make it smaller</li>
      </ul></li>
      </ul>
      <p><strong>Convention</strong>: By convention for priority queues we understand the item with the <em>smallest</em> priority value to be the <q>most important</q>, and it is therefore what gets returned by the extract operation. This comes from the idea that priorities are communicated as rankings in the English language, and so saying <q>you’re my number one priority</q> is saying <q>you’re the most important to me</q>. We can also define priority queues so that the item with the largest priority value is the most important with only trivial changes. Because of this convention, though, all the examples below consider the smaller priority values more important.</p>
      <h2 id="priority-queues-using-lists"><span class="header-section-number">1.1</span> Priority Queues Using Lists</h2>
      <p>Next we can look at some examples of data structures for priority queues. With the queue ADT, we were able to effectively use list-like approaches for designing out data structures, so let’s try that same thing here. This can give us to better understand the challenges of creating a priority queue data structure, and help us to see what we might need to do to improve upon some relatively more straight forward approaches.</p>
      <h3 id="unsorted-array-priority-queue"><span class="header-section-number">1.1.1</span> Unsorted Array Priority Queue</h3>
      <p>First, let’s look at what we might do if we just store the elements (and priorities) in an unsorted array. In this case we might have a field that we could call <em>back</em> to indicate the index of the last item in the array. From here we could use the following algorithms for the priority queue ADT operations insert and extract:</p>
      <ul>
      <li>insert: add the item and its priority into the array at the index referenced by <em>back</em>, resizing if necessary. Then increment <em>back</em>.</li>
      <li>extract: iterating from index 0 of the array up through index <em>back</em>, save the index and priority of the item with the smallest priority seen so far. Return the corresponding item, and remove it from the array by shifting all elements after it over by 1 index.</li>
      </ul>
      <p>Because we do not care to impose any kind of ordering of the elements in our array, our insert algorithm runs in constant time. However, because we have no indication for where we might find the item with smallest priority, the extract operation requires linear time.</p>
      <h3 id="sortest-array-priority-queue"><span class="header-section-number">1.1.2</span> Sortest Array Priority Queue</h3>
      <p>Because priority queues require removing items in a sorted order, perhaps we could improve our data structure by requiring the items be stored in descending order (largest priority value at index 0, smallest at index <span class="math inline">n-1</span>). In this data structure we will also have the field <em>back</em> that indicates the index of the last item in the array (in this case this will be the one with the smallest priority value). Here’s what insert and extract might look like in this case:</p>
      <ul>
      <li>insert: starting from index 0, check to see if the new item has higher priority than the one at that current index, if not then check the next index, repeat until we reach an item with lower priority or until we reach <em>back</em>. Next insert the new item at the current index by shifting all items after that index over by one position. Increment back. Resize if necessary.</li>
      <li>extract: because we sorted in descending order, the index <em>back</em> has the minimum priority. Decrement the value of <em>back</em> and retun the value at the index <em>back</em>.</li>
      </ul>
      <p>Because we need to keep our array sorted, we need to be very careful about where we add values into our array, and so the running time of insert is linear time. On the other hand, extract requires only constant time because we know exactly where the element with minimum priority might be.</p>
      <h3 id="lessons"><span class="header-section-number">1.1.3</span> Lessons</h3>
      <p>From these two examples it appears that there’s a tradeoff in our data structure design: stricter ordering makes insert harder and extract easier, more relaxed ordering makes insert easier and extract harder. This provides the motivate for the binary heap data structure that we will soon introduce for priority queues. In a binary heap we will store our elements in an array, but they will be only <em>somewhat</em> ordered so that we can have sublinear running time for <em>both</em> insert and extract. Specifically, we will achieve running times of <span class="math inline">\Theta(\log n)</span> for both insert and extract.</p>
      <h1 id="binary-heap-data-structure"><span class="header-section-number">2</span> Binary Heap Data Structure</h1>
      <p>In impelementation, our binary heap data structure will store elements in an array, but manipulate the positions of elements as if they were stored in a binary tree. In other words, it will be representing a tree using an array. To describe this data structure we will first describe it as a tree, then later describe how we represent the tree using an array.</p>
      <h2 id="the-shape-of-the-tree"><span class="header-section-number">2.1</span> The Shape of the Tree</h2>
      <p>Binary heaps have <em>very</em> strict requirements on the structure of the tree that stores the elements. Specifically, the <em>structure property</em> of a heap requires:</p>
      <ul>
      <li>Every level of the tree be <em>completely full</em> before any items may be included on the next level</li>
      <li>If the last level is only partially full, the items <em>must</em> be filled in from left to right (so for example the left child of the left-most node of the second from last level must be the first to be filled in).</li>
      </ul>
      <p>There are two motives for this:</p>
      <ol type="1">
      <li>This shape will help us to achieve the <span class="math inline">\Theta(\log n)</span> worst case running times for insert and extract</li>
      <li>This shape will help us to represent the tree using an array</li>
      </ol>
      <p>To help understand the requirements, here are a few <em>valid</em> tree shapes:</p>
      <p>TODO!</p>
      <p>Here are a few trees that are <em>not</em> a valid shape:</p>
      <p>TODO!</p>
      <h2 id="somewhat-ordering-the-array"><span class="header-section-number">2.2</span> Somewhat Ordering the Array</h2>
      <p>In addition to requiring a particular shape to the tree, heaps also require restrictions on where certain values may appear. For a min heap (i.e. one where the most important element has the lowest priority value) the following property must be true of every node in the tree:</p>
      <p><strong>Min Heap Property</strong>: For every node in the tree, the priority value of that node must be less than or equal to that of its children.</p>
      <p>This heap property ensures that for every node, the priority of the value held there is the smallest of all nodes in its subtree. This is because if there was any node within a subtree with a smaller priority value then that node or one of its ancestors must violate the heap property with its parent. Since this applies to all nodes, that implies that the overall root of the heap <em>must</em> contain the element with the smallest priority. Therefore this heap property gives us one of the advantages of a sorted array in that we know exactly where to find the most important item.</p>
      <p>The heap property also doesn’t require our array to be <em>too</em> sorted. Note that the heap property only enforces a priority relationship between a node and any values in its subtree. It does not have any restrictions on how a node’s priority value might relate to those of nodes in different branches of the tree (e.g. <q>cousin</q> nodes or <q>aunt/uncle</q> nodes). The result here will be that it does not require too much effort to maintain the heap property when adding/removing items from the heap (at least, it requires much less effort than maintaining a total ordering). Namely, since the heap property can be checked by just checking how parents relat to children, the heap property ensures that we need to do only a constant number of operations per level of the tree to restore the heap property after any insert/extract operation. The shape property then guarantees that the tree will not have many levels. The combination of these two rules therefore enables our fast (<span class="math inline">\Theta(\log n)</span>) running time for each operation.</p>
      <h2 id="the-tree-representation-using-an-array"><span class="header-section-number">2.3</span> The Tree Representation Using an Array</h2>
      <p>Now let’s discuss how we can represent our heap using an array. When you learned about binary trees in your prerequisite course, you likely used nodes where each stored the value it contains and then had a reference to two other nodes representing its left and right children. For heaps we will store our values in an array, and then identify a node’s left and right children by doing arithmetic on array indices.</p>
      <p>To represent our heap as an array we will leverage the heap structure property. The structure property is so strict that all trees of the same size <em>must</em> have the same shape. This is because there is a unique position that must be added to accommodate that new node. To represent our tree using an array, we will designate that the position added when adding the <span class="math inline">i</span>th node will be stored at index <span class="math inline">i</span>. In summary, we can identify each node’s index by <q>counting off</q> one level at a time, and then left-to-right within a level. The structure property insures that this assignment will never skip nodes and will never skip array indices. We will always start the <q>counting off</q> from the root. We could decide to start that count with the number <span class="math inline">0</span> (thereby putting the root at index <span class="math inline">0</span> of the array), however the arithmetic we’ll need to apply to the array indices in order to navigate the tree is a bit easier if we start of with <span class="math inline">1</span> instead (thereyby not using index <span class="math inline">0</span> of the array at all).</p>
      <p>Here’s an example of how we can store a heap using an array:</p>
      <p>TODO</p>
      <p>For a node at index <span class="math inline">i</span>, here’s how we can calculate the index of the following other nodes in relation to <span class="math inline">i</span>:</p>
      <ul>
      <li>Its left child: <span class="math inline">2i</span></li>
      <li>Its right child: <span class="math inline">2i+1</span></li>
      <li>Its parent <span class="math display">\lfloor \frac{i}{2}\rfloor</span></li>
      <li>Its left sibling: <span class="math inline">i-1</span> (this requires that <span class="math inline">i</span> is itself a right child)</li>
      <li>Its right sibling: <span class="math inline">i+1</span> (this requires that <span class="math inline">i</span> is itself a left child)</li>
      </ul>
      <h2 id="insert-and-extract-algorithms"><span class="header-section-number">2.4</span> Insert and Extract Algorithms</h2>
      <p>Since we’ve fully described how we’re representing our data, let’s discuss our algorithms for the priority queue ADT operations.</p>
      <h3 id="insert"><span class="header-section-number">2.4.1</span> Insert</h3>
      <p>When inserting an element, the structure property of heaps designates a unique position that must be created in the heap. Namely, if the last level of the heap is not full then after adding a new item the new position must be the leftmost available slot of that last level. If the last level of the heap is full, then the new position must be the leftmost on the next level.</p>
      <p>While the structure property designates a specific new position, we cannot necessarily just put the new item there. The heap property requires each node’s priority be less than or equal to its children. It could be that the newly-added item has a priority smaller than the parent of the new position we were required to create. In this case, we must rearrange values of the heap in order to maintain the heap property.</p>
      <p>The idea of our algorithm is as follows: 1. Place the new item at the position dictated by the structure property 1. Compare that item’s priority with that of it’s parent. If the new item has a lower priority than its parent then swap the new item’s position with that of its parent. 1. Repeat the previous step (comare the new item with its parent, swap less than) until either the new item’s priority value is greater than or equal to its parent, or the new item becomes the new root.</p>
      <p>Keeping in mind that the tree itself is represented using an array, this results in the following near-Java code:</p>
      <pre><code>public void insert(T item){
          if(this.size() == arr.length){
              resize();  // replace with a larger array, copy over the contents
          }
          arr[size+1] = item; // we&#39;re 1-indexing so we need to use size+1
          size++;
          int currIndex = size; // tindex currently holding the new item
          while(currIndex//2 &gt; 0 &amp;&amp; arr[currIndex].priority &lt; arr[currIndex//2]){ // until the new item is either the root or its priority is larger than its parent&#39;s
              T oldParent = arr[currIndex//2]; // save the parent
              arr[currIndex//2]= arr[currIndex]; // move the new item to the parent&#39;s position
              arr[currIndex] = oldParent; // move the parent to the new item&#39;s former position
              currIndex = currIndex // 2; // update the index of the new item
          }
      }</code></pre>
      <h3 id="percolate-up-and-down"><span class="header-section-number">2.4.2</span> Percolate Up and Down</h3>
      <h3 id="running-time-analysis"><span class="header-section-number">2.4.3</span> Running time analysis</h3>
      <h3 id="increasedecrease-key"><span class="header-section-number">2.4.4</span> Increase/Decrease Key</h3>
      <h1 id="floyds-build-heap-method"><span class="header-section-number">3</span> Floyd’s Build Heap Method</h1>
            </div>
    </div>
  </div>
  <footer>
          Copyright © 2026 Nathan Brunelle.
              <p>Released under the <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /> CC-BY-NC-SA 4.0</a> license</a>.
      </p>
        <p>Last updated 2026-01-15 13:25</p>
  </footer>
</body>
</html>
